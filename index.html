<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Сканер Объектов в Пространстве</title>
    <!-- Загрузка Tailwind CSS для стилей интерфейса -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <!-- Загрузка библиотек A-Frame и AR.js для WebAR -->
    <!-- A-Frame - основа для 3D/AR -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- AR.js - добавляет функциональность отслеживания. В markerless режиме использует сенсоры устройства. -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        /* Стиль для оверлея, который будет поверх AR-сцены */
        #ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Позволяет кликам проходить сквозь оверлей на AR-объекты */
            z-index: 100;
        }

        /* Стиль для начального экрана */
        #ar-start-button-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 200; /* Выше AR-оверлея */
            pointer-events: auto;
        }
        
        /* Убедимся, что A-Frame занимает весь экран */
        a-scene {
            height: 100vh;
            width: 100vw;
            display: block;
            opacity: 0; /* Скрываем сцену по умолчанию */
            transition: opacity 0.5s;
        }

        /* Переопределяем pointer-events для интерактивных элементов внутри оверлея */
        .interactive-ui {
            pointer-events: auto;
        }

        /* Стиль для индикатора направления */
        #direction-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px; /* Размер стрелки */
            height: 60px;
            pointer-events: none;
            z-index: 150;
            /* transform: translate(-50%, -50%) - Стилизация в JS для динамического поворота */
        }
    </style>
</head>
<body class="bg-gray-900 font-sans h-screen w-screen overflow-hidden">

    <!-- Интерфейс пользователя (Оверлей) -->
    <div id="ar-overlay">
        <div class="p-4 flex justify-between items-start interactive-ui">
            <!-- Отображение очков -->
            <div id="score-display" class="bg-indigo-600 text-white font-bold text-xl px-4 py-2 rounded-lg shadow-lg">
                Очки: 0
            </div>
            <!-- Инструкция/Сообщение -->
            <div id="message-box" class="bg-yellow-300 text-gray-800 font-medium px-4 py-2 rounded-lg shadow-lg max-w-xs text-sm">
                Загрузка AR-сцены...
            </div>
        </div>

        <!-- Индикатор направления (Стрелка) -->
        <div id="direction-indicator" style="display:none;">
            <svg viewBox="0 0 100 100" class="w-full h-full text-yellow-400 drop-shadow-lg" style="opacity: 0.9;">
                <!-- Простая стрелка, указывающая вверх (0 градусов) -->
                <path fill="currentColor" d="M 50 10 L 80 40 L 60 40 L 60 90 L 40 90 L 40 40 L 20 40 Z"/>
            </svg>
        </div>

        <div id="feedback-message" class="absolute inset-x-0 bottom-20 text-center interactive-ui">
            <!-- Сообщения об успехе или ошибке -->
        </div>
    </div>

    <!-- Начальный экран с кнопкой запуска для обхода ограничений iOS/Safari -->
    <div id="ar-start-button-overlay">
        <h1 class="text-white text-2xl font-bold mb-6">AR-поиск объектов</h1>
        <p class="text-gray-300 text-center mb-10 max-w-sm">Для начала потребуется разрешение на использование камеры и датчиков движения.</p>
        <button id="startButton" class="interactive-ui bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 rounded-full shadow-2xl transition duration-200 transform hover:scale-105">
            Начать AR-сессию
        </button>
    </div>

    <!-- Скрытый элемент для нативного видеопотока (КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ ДЛЯ ANDROID) -->
    <video id="arVideoElement" 
           style="position: fixed; top: 1px; left: 1px; width: 1px; height: 1px; z-index: -1; opacity: 0;" 
           playsinline preload>
    </video>

    <!-- WebAR Сцена (A-Frame) -->
    <a-scene
        
        id="ar-scene"
        embedded
        vr-mode-ui='enabled: false;'
        renderer="logarithmicDepthBuffer: true;"
        loading-screen="enabled: false;"
        direction-indicator>

        <!-- AR-объект, который будет давать очки -->
        <a-box
            id="ar-object"
            position="0 0 -3"  
            rotation="0 45 0"
            scale="0.5 0.5 0.5"
            color="#FF4500"
            material="opacity: 0.9; metalness: 0.5;"
            shadow>
        </a-box>

        <!-- Камера, необходимая для AR.js в режиме отслеживания ориентации устройства -->
        <a-entity camera></a-entity>
    </a-scene>


    <script>
        // ====================================================================
        // A-FRAME КОМПОНЕНТ ДЛЯ ИНДИКАТОРА НАПРАВЛЕНИЯ
        // ====================================================================
        AFRAME.registerComponent('direction-indicator', {
            init: function () {
                // Получаем 3D-объекты сцены
                this.camera = document.querySelector('a-entity[camera]').object3D;
                this.target = document.getElementById('ar-object').object3D;
                this.indicator = document.getElementById('direction-indicator');
                
                // Векторы для расчетов, инициализированные один раз для переиспользования
                this.targetWorldPos = new THREE.Vector3();
                this.cameraWorldPos = new THREE.Vector3();
                this.vectorToTarget = new THREE.Vector3();
            },

            tick: function () {
                const targetEl = document.getElementById('ar-object');

                // Проверка, виден ли объект (не скрыт ли он после сбора очков)
                if (!targetEl.getAttribute('visible')) {
                    this.indicator.style.display = 'none';
                    return;
                }

                // 1. Получаем мировые позиции цели и камеры
                this.target.getWorldPosition(this.targetWorldPos);
                this.camera.getWorldPosition(this.cameraWorldPos);
                
                // 2. Рассчитываем вектор от камеры к цели
                this.vectorToTarget.subVectors(this.targetWorldPos, this.cameraWorldPos);
                
                // 3. Определяем угол в горизонтальной плоскости (XZ)
                // targetAngleRad - это угол, на который объект отклонен от мирового Z-forward
                const targetAngleRad = Math.atan2(this.vectorToTarget.x, this.vectorToTarget.z); 
                
                // 4. Получаем текущее вращение камеры по оси Y (курс)
                // Rotation.y уже включает данные гироскопа/ориентации устройства
                const cameraYRotationRad = this.camera.rotation.y;
                
                // 5. Разница углов: насколько нужно повернуть экран, чтобы цель была впереди
                let angleDiffRad = targetAngleRad - cameraYRotationRad;

                // Нормализация угла к диапазону [-PI, PI]
                while (angleDiffRad > Math.PI) angleDiffRad -= 2 * Math.PI;
                while (angleDiffRad < -Math.PI) angleDiffRad += 2 * Math.PI;

                const angleDiffDeg = angleDiffRad * (180 / Math.PI);

                // 6. Проверка порога (скрыть, если цель в центре обзора)
                const threshold = 15; // 15 градусов
                if (Math.abs(angleDiffDeg) < threshold) {
                     this.indicator.style.display = 'none';
                } else {
                     this.indicator.style.display = 'block';
                     // Вращаем индикатор. Стрелка указывает вверх (0 deg), поэтому поворот должен быть
                     // противоположен разнице углов (-angleDiffDeg)
                     this.indicator.style.transform = `translate(-50%, -50%) rotate(${-angleDiffDeg}deg)`;
                }
            }
        });


        // ====================================================================
        // ОСНОВНАЯ ЛОГИКА ИНТЕРФЕЙСА И ЗАПУСКА
        // ====================================================================
        
        const scoreDisplay = document.getElementById('score-display');
        const messageBox = document.getElementById('message-box');
        const feedbackMessage = document.getElementById('feedback-message');
        const arObject = document.getElementById('ar-object');
        const startButtonOverlay = document.getElementById('ar-start-button-overlay');
        const startButton = document.getElementById('startButton');
        const arScene = document.getElementById('ar-scene');
        const videoElement = document.getElementById('arVideoElement'); 

        let score = 0;
        let objectVisible = true; 
        let currentStream = null; // Глобальная переменная для хранения потока камеры

        // Функция для обновления интерфейса
        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = `Очки: ${score}`;
            showFeedback(`+${points} Очко!`, 'bg-green-500');
        }

        // Показывает временное сообщение обратной связи
        function showFeedback(text, bgColor) {
            feedbackMessage.innerHTML = `<div class="${bgColor} text-white font-bold px-6 py-3 rounded-full shadow-xl animate-pulse text-lg">${text}</div>`;
            setTimeout(() => {
                feedbackMessage.innerHTML = '';
            }, 1500);
        }

        // Функция для перемещения объекта в случайные координаты (X, Y, Z)
        function relocateObject() {
            // Генерируем случайные координаты в пределах, которые легко увидеть
            const x = (Math.random() * 6) - 3; 
            const y = (Math.random() * 6) - 3;
            const z = (Math.random() * -3) - 4; 
            
            // Устанавливаем новую позицию объекта в A-Frame
            arObject.setAttribute('position', `${x.toFixed(2)} ${y.toFixed(2)} ${z.toFixed(2)}`);
            console.log(`Объект перемещен на: ${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}`);

            messageBox.textContent = 'Объект переместился! Посмотрите вокруг, чтобы найти его!';
            messageBox.classList.remove('bg-green-400', 'bg-red-600');
            messageBox.classList.add('bg-purple-400');
        }

        // Обработчик клика/нажатия на 3D объект
        arObject.addEventListener('click', function (evt) {
            if (objectVisible) {
                // Предотвращаем многократное нажатие, пока объект "перезаряжается"
                if (arObject.getAttribute('data-scored') !== 'true') {
                    arObject.setAttribute('data-scored', 'true');
                    updateScore(10); // Начисляем 10 очков
                    
                    // Делаем объект временно невидимым/некликабельным
                    arObject.setAttribute('visible', false);
                    
                    // Задержка (3 секунды) перед тем, как объект появится в новой точке
                    setTimeout(() => {
                        relocateObject(); // ПЕРЕМЕЩАЕМ ОБЪЕКТ В СЛУЧАЙНЫЕ КООРДИНАТЫ
                        arObject.setAttribute('data-scored', 'false');
                        arObject.setAttribute('visible', true);
                        showFeedback('Найдите новый объект!', 'bg-blue-500');
                    }, 3000); 

                } else {
                    showFeedback('Подождите, объект перезаряжается...', 'bg-red-500');
                }
            } else {
                 showFeedback('Объект не виден!', 'bg-red-500');
            }
        });

        // ====================================================================
        // 2. ЛОГИКА ЗАПУСКА КАМЕРЫ И РАЗРЕШЕНИЙ (НАДЕЖНЫЙ МЕТОД + ПОВТОРЫ)
        // ====================================================================
        
        // Функция для остановки текущего потока камеры (КРИТИЧНО для NotReadableError)
        function stopCameraStream() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
                console.log("Предыдущий поток камеры остановлен.");
            }
        }

        function handleCameraError(error) {
            startButtonOverlay.style.display = 'flex';
            arScene.style.opacity = '0';
            stopCameraStream(); // Убедимся, что поток остановлен при ошибке
            
            let userMessage = 'Неизвестная ошибка камеры.';
            
            if (error.name === 'NotAllowedError') {
                userMessage = 'Доступ к камере заблокирован. Пожалуйста, проверьте настройки разрешений вашего браузера/Telegram.';
            } else if (error.name === 'NotReadableError') {
                 // ИНФОРМАТИВНОЕ СООБЩЕНИЕ ДЛЯ ПОЛЬЗОВАТЕЛЯ
                 userMessage = 'Камера занята. Пожалуйста, убедитесь, что ни одно другое приложение (например, камера телефона) не использует ее, и попробуйте снова.';
            } else if (error.name === 'NotFoundError') {
                userMessage = 'Камера не найдена.';
            } else if (error.message && error.message.includes('Only secure origins are allowed')) {
                 userMessage = 'Ошибка безопасности: для камеры требуется HTTPS-соединение.';
            } else {
                 userMessage = `Ошибка: ${error.name}. Пожалуйста, попробуйте перезагрузить.`;
            }

            messageBox.textContent = userMessage;
            messageBox.classList.remove('bg-green-400', 'bg-blue-500', 'bg-purple-400');
            messageBox.classList.add('bg-red-600', 'text-white');
            console.error("Manual Camera Error:", error);
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function requestCameraStream(retries = 3) {
            stopCameraStream(); // Останавливаем предыдущий поток перед началом нового запроса

            for (let i = 0; i < retries; i++) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    currentStream = stream; // Сохраняем новый поток
                    return stream;
                } catch (error) {
                    // Если NotReadableError и это не последняя попытка, ждем и пробуем снова
                    if (error.name === 'NotReadableError' && i < retries - 1) {
                        console.warn(`Попытка получить камеру не удалась (${i + 1}/${retries}). NotReadableError. Повтор через 500 мс.`);
                        await delay(500);
                    }
                    // В случае другой ошибки или последней попытки NotReadableError
                    throw error;
                }
            }
        }


        // СТАЛО (Надежный запуск через события 'loadedmetadata' и 'playing')
        async function finalizeStart() {
            // 1. Скрываем кнопку
            startButtonOverlay.style.display = 'none';
            messageBox.textContent = 'Запуск камеры...';
            
            try {
                // 2. Нативный запрос потока камеры с логикой повтора
                const stream = await requestCameraStream();
                
                videoElement.srcObject = stream;

                // 3. Создаем слушатель для события 'onplaying'
                //    Это событие срабатывает, когда кадры *реально* начали рендериться.
                const onPlaying = () => {
                    console.log("Видеопоток 'onplaying' сработал.");
                    
                    // Удаляем слушатель, чтобы он не сработал снова
                    videoElement.removeEventListener('playing', onPlaying);

                    // 4. ТЕПЕРЬ, когда видео *точно* проигрывается, ИНИЦИАЛИЗИРУЕМ AR.js
                    console.log("Применяем атрибут AR.js к сцене...");
                    arScene.setAttribute('arjs', 'sourceType: video; sourceUrl: #arVideoElement; trackingMethod: best;');

                    // Даем AR.js один-два кадра на "прогрев" и инициализацию
                    // Это безопаснее, чем делать это в том же кадре
                    setTimeout(() => {
                        // 5. Показываем AR сцену
                        arScene.style.opacity = '1';
                        window.dispatchEvent(new Event('resize')); // Хак для WebView

                        console.log("Видеопоток камеры успешно запущен.");
                        relocateObject(); 

                        messageBox.textContent = 'Объект загружен! Посмотрите вокруг.';
                        messageBox.classList.remove('bg-yellow-300', 'bg-blue-500', 'bg-red-600', 'bg-purple-400');
                        messageBox.classList.add('bg-green-400');
                    }, 50); // 50 мс достаточно
                };

                // 2b. Создаем слушатель для 'onloadedmetadata'
                //     Он нужен, чтобы мы могли вызвать .play()
                const onLoadedMetadata = () => {
                    console.log("Видео 'onloadedmetadata' сработало. Вызываем play().");
                    videoElement.removeEventListener('loadedmetadata', onLoadedMetadata);
                    
                    // Пытаемся запустить видео. Как только оно *начнет* играть,
                    // сработает наш слушатель 'onPlaying'.
                    videoElement.play().catch(handleCameraError); 
                };
                
                // Назначаем оба слушателя
                videoElement.addEventListener('loadedmetadata', onLoadedMetadata);
                videoElement.addEventListener('playing', onPlaying);


            } catch (error) {
                handleCameraError(error); // Обработка ошибки getUserMedia()
            }
        }

        function startARSession() {
            // 1. Запрос разрешения на датчики (только iOS)
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && typeof DeviceOrientationEvent.requestPermission === 'function';
            
            if (isIOS) {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        console.log("Device Orientation permission:", permissionState);
                        finalizeStart();
                    })
                    .catch(() => {
                        finalizeStart();
                    });
            } else {
                finalizeStart();
            }
        }
        

        // ====================================================================
        // 3. ОБРАБОТКА ЗАГРУЗКИ (ИНИЦИАЛИЗАЦИЯ)
        // ====================================================================

        window.onload = function() {
            messageBox.textContent = 'Нажмите "Начать AR-сессию" для продолжения.';
            messageBox.classList.remove('bg-yellow-300', 'bg-green-400', 'bg-purple-400', 'bg-red-600');
            messageBox.classList.add('bg-blue-500');

            // Добавляем обработчик на кнопку
            startButton.addEventListener('click', startARSession);
        };
    </script>
</body>
</html>
