<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Сканер Объектов в Пространстве</title>
    <!-- Загрузка Tailwind CSS для стилей интерфейса -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <!-- Загрузка библиотек A-Frame и AR.js для WebAR -->
    <!-- A-Frame - основа для 3D/AR -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- AR.js - добавляет функциональность отслеживания. В markerless режиме использует сенсоры устройства. -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        /* Стиль для оверлея, который будет поверх AR-сцены */
        #ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Позволяет кликам проходить сквозь оверлей на AR-объекты */
            z-index: 100;
        }

        /* Стиль для начального экрана */
        #ar-start-button-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 200; /* Выше AR-оверлея */
            pointer-events: auto;
        }
        
        /* Убедимся, что A-Frame занимает весь экран */
        a-scene {
            height: 100vh;
            width: 100vw;
            display: block;
            opacity: 0; /* Скрываем сцену по умолчанию */
            transition: opacity 0.5s;
        }

        /* Переопределяем pointer-events для интерактивных элементов внутри оверлея */
        .interactive-ui {
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-gray-900 font-sans h-screen w-screen overflow-hidden">

    <!-- Интерфейс пользователя (Оверлей) -->
    <div id="ar-overlay">
        <div class="p-4 flex justify-between items-start interactive-ui">
            <!-- Отображение очков -->
            <div id="score-display" class="bg-indigo-600 text-white font-bold text-xl px-4 py-2 rounded-lg shadow-lg">
                Очки: 0
            </div>
            <!-- Инструкция/Сообщение -->
            <div id="message-box" class="bg-yellow-300 text-gray-800 font-medium px-4 py-2 rounded-lg shadow-lg max-w-xs text-sm">
                Загрузка AR-сцены...
            </div>
        </div>

        <div id="feedback-message" class="absolute inset-x-0 bottom-20 text-center interactive-ui">
            <!-- Сообщения об успехе или ошибке -->
        </div>
    </div>

    <!-- Начальный экран с кнопкой запуска для обхода ограничений iOS/Safari -->
    <div id="ar-start-button-overlay">
        <h1 class="text-white text-2xl font-bold mb-6">AR-поиск объектов</h1>
        <p class="text-gray-300 text-center mb-10 max-w-sm">Для начала потребуется разрешение на использование камеры и датчиков движения.</p>
        <button id="startButton" class="interactive-ui bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 rounded-full shadow-2xl transition duration-200 transform hover:scale-105">
            Начать AR-сессию
        </button>
    </div>

    <!-- WebAR Сцена (A-Frame) -->
    <a-scene
        id="ar-scene"
        embedded
        arjs='sourceType: webcam; trackingMethod: best;'
        vr-mode-ui='enabled: false;'
        renderer="logarithmicDepthBuffer: true;"
        loading-screen="enabled: false;">

        <!-- AR-объект, который будет давать очки -->
        <a-box
            id="ar-object"
            position="0 0 -3"  
            rotation="0 45 0"
            scale="0.5 0.5 0.5"
            color="#FF4500"
            material="opacity: 0.9; metalness: 0.5;"
            shadow>
        </a-box>

        <!-- Камера, необходимая для AR.js в режиме отслеживания ориентации устройства -->
        <a-entity camera></a-entity>
    </a-scene>


    <script>
        const scoreDisplay = document.getElementById('score-display');
        const messageBox = document.getElementById('message-box');
        const feedbackMessage = document.getElementById('feedback-message');
        const arObject = document.getElementById('ar-object');
        const startButtonOverlay = document.getElementById('ar-start-button-overlay');
        const startButton = document.getElementById('startButton');
        const arScene = document.getElementById('ar-scene');

        let score = 0;
        let objectVisible = true; 

        // ====================================================================
        // 1. ЛОГИКА ПЕРЕМЕЩЕНИЯ И НАЧИСЛЕНИЯ ОЧКОВ
        // ====================================================================

        // Функция для обновления интерфейса
        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = `Очки: ${score}`;
            showFeedback(`+${points} Очко!`, 'bg-green-500');

            // Здесь вы можете вызвать функцию Dart/Flutter, если бы это было встроено:
            // window.flutter_inappwebview.callHandler('addPoints', score);
        }

        // Показывает временное сообщение обратной связи
        function showFeedback(text, bgColor) {
            feedbackMessage.innerHTML = `<div class="${bgColor} text-white font-bold px-6 py-3 rounded-full shadow-xl animate-pulse text-lg">${text}</div>`;
            setTimeout(() => {
                feedbackMessage.innerHTML = '';
            }, 1500);
        }

        // Функция для перемещения объекта в случайные координаты (X, Y, Z)
        function relocateObject() {
            // Генерируем случайные координаты в пределах, которые легко увидеть
            // X и Y между -3 и 3 (горизонтальное/вертикальное смещение)
            const x = (Math.random() * 6) - 3; 
            const y = (Math.random() * 6) - 3;
            // Z между -4 и -7 (глубина, всегда перед камерой)
            const z = (Math.random() * -3) - 4; 
            
            // Устанавливаем новую позицию объекта в A-Frame
            arObject.setAttribute('position', `${x.toFixed(2)} ${y.toFixed(2)} ${z.toFixed(2)}`);
            console.log(`Объект перемещен на: ${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}`);

            messageBox.textContent = 'Объект переместился! Посмотрите вокруг, чтобы найти его!';
            messageBox.classList.remove('bg-green-400');
            messageBox.classList.add('bg-purple-400');
        }

        // Обработчик клика/нажатия на 3D объект
        arObject.addEventListener('click', function (evt) {
            if (objectVisible) {
                // Предотвращаем многократное нажатие, пока объект "перезаряжается"
                if (arObject.getAttribute('data-scored') !== 'true') {
                    arObject.setAttribute('data-scored', 'true');
                    updateScore(10); // Начисляем 10 очков
                    
                    // Делаем объект временно невидимым/некликабельным
                    arObject.setAttribute('visible', false);
                    
                    // Задержка (3 секунды) перед тем, как объект появится в новой точке
                    setTimeout(() => {
                        relocateObject(); // ПЕРЕМЕЩАЕМ ОБЪЕКТ В СЛУЧАЙНЫЕ КООРДИНАТЫ
                        arObject.setAttribute('data-scored', 'false');
                        arObject.setAttribute('visible', true);
                        showFeedback('Найдите новый объект!', 'bg-blue-500');
                    }, 3000); 

                } else {
                    showFeedback('Подождите, объект перезаряжается...', 'bg-red-500');
                }
            } else {
                 showFeedback('Объект не виден!', 'bg-red-500');
            }
        });

        // ====================================================================
        // 2. ЛОГИКА ЗАПУСКА И РАЗРЕШЕНИЙ (FIX ДЛЯ МОБИЛЬНЫХ)
        // ====================================================================
        
        function startARSession() {
            // 1. Сначала пытаемся запросить разрешение на датчики движения (для iOS 13+)
            // Это должно происходить после пользовательского жеста (клика)
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            
            if (isIOS && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            console.log("Device Orientation permission granted.");
                        } else {
                            console.warn("Device Orientation permission denied.");
                        }
                        // В любом случае продолжаем, чтобы запустить камеру
                        finalizeStart();
                    })
                    .catch(error => {
                        console.error("Error requesting Device Orientation permission:", error);
                        // Продолжаем, на случай если ошибка не критична
                        finalizeStart();
                    });
            } else {
                // Для Android или старых iOS/других браузеров, где это не требуется
                finalizeStart();
            }
        }
        
        function finalizeStart() {
            // 2. Скрываем кнопку
            startButtonOverlay.style.display = 'none';
            
            // 3. Добавляем небольшую задержку и хак для инициализации камеры на Android
            setTimeout(() => {
                // Показываем AR сцену
                arScene.style.opacity = '1';

                // Хак: Явно вызываем событие resize. Это заставляет AR.js
                // пересчитать размеры и часто помогает корректно запустить видеопоток
                // в проблемных WebView-окружениях (как в TMA на Android).
                window.dispatchEvent(new Event('resize'));
                
                // 4. Завершение инициализации
                console.log("WebAR Demo загружено и готово.");
                
                // Случайное размещение объекта при первом запуске
                relocateObject(); 

                messageBox.textContent = 'Объект загружен! Посмотрите вокруг.';
                messageBox.classList.remove('bg-yellow-300');
                messageBox.classList.add('bg-green-400');
            }, 50); // Небольшая задержка 50ms для стабильности

            // В реальном TMA, когда этот HTML загружен, вы можете
            // уведомить Flutter/TMA о готовности:
            // if (window.Telegram && window.Telegram.WebApp) {
            //     Telegram.WebApp.ready();
            // }
        }

        // ====================================================================
        // 3. ОБРАБОТКА ЗАГРУЗКИ (ИНИЦИАЛИЗАЦИЯ)
        // ====================================================================

        window.onload = function() {
            messageBox.textContent = 'Нажмите "Начать AR-сессию" для продолжения.';
            messageBox.classList.remove('bg-yellow-300');
            messageBox.classList.add('bg-blue-500');

            // Добавляем обработчик на кнопку
            startButton.addEventListener('click', startARSession);
        };
    </script>
</body>
</html>
